// Ширяев Антон 25.11.2011 - Расчет хеша SHA1 от строки
// При написание алгоритма использовалась информация из http://ru.wikipedia.org/wiki/SHA-1

VAR T1,T6,T8,K,HEX,ALF_BASE64;

// Функция выполняет циклический сдвиг битов слова влево
Функция _LR(A,S) 
	Возврат Цел(A/T1[32-S])+T1[S]*(A%T1[32-S]);
КонецФункции

Функция _F1(Знач A,Знач B,Знач C) R=0;
	Для I=1 По 32 Цикл 
		M=T1[32-I];
		R=R+M*?((A>=M)<>((B>=M)И((C>=M)<>(A>=M))),1,0);
		A=?(A<M,A,A-M);
		B=?(B<M,B,B-M);
		C=?(C<M,C,C-M);
	КонецЦикла;
	Возврат R;
КонецФункции

Функция _F2(Знач A,Знач B,Знач C) R=0;
	Для I=1 По 32 Цикл
		M=T1[32-I];
		R=R+M*?((A<M)=(B<M)=(C<M),0,1);
		A=?(A<M,A,A-M);
		B=?(B<M,B,B-M);
		C=?(C<M,C,C-M);
	КонецЦикла;
	Возврат R;
КонецФункции

Функция _F3(Знач A,Знач B,Знач C)
	R=0;
	Для I=1 По 32 Цикл
		M=T1[32-I];
		R=R+M*?(((A>=M)И(B>=M))Или((C>=M)И((A>=M)Или(B>=M))),1,0);
		A=?(A<M,A,A-M);
		B=?(B<M,B,B-M);
		C=?(C<M,C,C-M);
	КонецЦикла;
	Возврат R;
КонецФункции

Функция _W(Знач A,Знач B,Знач C, Знач D)
	R=0;
	Для I=1 По 32 Цикл 
		M=T1[32-I];
		R=R+?(I=1,1,M*2)*?((A<M)=(B<M)=(C<M)=(D<M),0,1);
		A=?(A<M,A,A-M);
		B=?(B<M,B,B-M);
		C=?(C<M,C,C-M);
		D=?(D<M,D,D-M);
	КонецЦикла;
	Возврат R;
КонецФункции

// Функция вычисляет SHA-1 хеш от unicode-строки и возвращает массив из 5 слов с результатом
Функция _SHA1_H(S)
	W=Новый Массив(80);
	L=0; // Количество байт в исходной строке преобразованной в UTF-8
	R=0; // 32-битное временное число
	H=Новый Массив(5);
	H[0]=1732584193;
	H[1]=4023233417;
	H[2]=2562383102;
	H[3]=271733878;
	H[4]=3285377520;
	// Разбираем исходную строку в массив из 16 слов W (1 слово - 32-битное число)
	// Переводим UNICODE номер символа в UTF-8 представление (1 символ может занимать от 1 до 6 байт)
	Для I=1 По СтрДлина(S) Цикл
		C=КодСимвола(S,I);
		Если C<128 Тогда
			// Если код символа меньше 128, то на выходе получаем один байт N
			N=C;
			G=0;
		Иначе
			// Вычмсляем количество дополнительных байт G для преобразования символов с кодом больше 127
			G=Цел((Log(C)/Log(2)-6)/5)+1;
			// Вычисляем старшие биты D для первого байта
			D=128;
			Для J=1 По G Цикл
				D=D+pow(2,7-J);
			КонецЦикла;
			M=pow(64,G);
			// Получаем значение первого байта
			N=Цел(C/M)+D;
			// Отрезаем старшие биты от исходного кода символа
			C=C%M;
		КонецЕсли;
		Для J=0 По G Цикл
			// Записываем байт N в нужное положение слова R
			R=R+pow(256,3-L%4)*N;
			L=L+1;
			Если L%4=0 Тогда
				// Длина сообщения кратна 4 - записываем времееное слово R в массив стов W и обнуляем R
				W[Цел((L-1)%64/4)]=R;
				R=0;
				Если L%64=0 Тогда
					// Длина сообщения достигла 512 бит - выполняем раунд SHA-1
					_SHA1_ROUND(W,H);
				КонецЕсли;
			КонецЕсли;
			Если J=G Тогда
				// Это последня итерация, дальше рассчитывать не нужно
				Прервать;
			КонецЕсли;
			M=pow(64,G-J-1);
			// Получаем значение дополнительного байта
			N=Цел(C/M)+128;
			// Отрезаем старшие биты от текущего кода символа
			C=C%M;
		КонецЦикла;
	КонецЦикла;
	// Добавляем бит 1 к полученному сообщению и дополняем сообщение нулевыми битами до длины 448 бит
	R=R+T8[3-L%4]*128;
	W[Цел(L%64/4)]=R;
	Для I=Цел(L%64/4)+1 По 15 Цикл
		W[I]=0;
	КонецЦикла;
	Если L%64>55 Тогда 
		// Если не осталось места на запись длины сообщения, то выполняем раунд SHA-1 и обнуляем массив W
		_SHA1_ROUND(W,H);
		Для I=0 По 14 Цикл
			W[I]=0;
		КонецЦикла;
	КонецЕсли;
	// Записываем в последние 64 бита сообщения его исходную длину в битах и выполняем раунд SHA-1
	W[14]=Цел(L*8/pow(2,32));
	W[15]=L*8%pow(2,32);
	_SHA1_ROUND(W,H);
	Возврат H;
КонецФункции

// Функция вычисляет SHA-1 хеш от unicode-строки и возвращает его строковое HEX-представление
Функция _SHA1(S) Экспорт
	H=_SHA1_H(S);
	R=Новый Массив(5);
	Для I=0 По 4 Цикл 
		R[I]="";
	КонецЦикла;
	Для I = 1 По 8 Цикл 
		Для J = 0 По 4 Цикл
			R[J]=Сред(HEX,H[J]%16+1,1)+R[J];
			H[J]=Цел(H[J]/16);
		КонецЦикла;
	КонецЦикла;
	Возврат R[0]+R[1]+R[2]+R[3]+R[4];
КонецФункции

// Функция вычисляет SHA-1 хеш от unicode-строки и возвращает его BASE64-представление
Функция _SHA1_BASE64(S) Экспорт
	H=_SHA1_H(S);
    A=0;
	B=0;
	R="";
	Для Каждого E Из H Цикл
		B=B+32;
		A=A*pow(2,32)+E;
		Пока B>=6 Цикл
			B=B-6;
			R=R+Сред(ALF_BASE64,Цел(A/pow(2,B))+1,1);
			A=A%pow(2,B);
		КонецЦикла;
	КонецЦикла;
	R=R+Сред(ALF_BASE64,A*4+1,1)+"=";
	Возврат R;
КонецФункции

// Процедура выполняет одну итерацию алгоритма SHA-1 над массивом W, возвращая значение в H
Процедура _SHA1_ROUND(W,H) 
	Для I=16 По 79 Цикл
		W[I]=_W(W[I-3],W[I-8],W[I-14],W[I-16]);
	КонецЦикла;
	A=H[0];
	B=H[1];
	C=H[2];
	D=H[3];
	E=H[4];
	Для I=0 По 79 Цикл
		T=(_LR(A,5)+?(I<20,_F1(D,B,C),?(I>39 И I<60,_F3(B,C,D),_F2(B,C,D)))+E+K[Цел(I/20)]+W[I])%pow(2,32);
		E=D;
		D=C;
		C=_LR(B,30);
		B=A;A=T;
	КонецЦикла;
	// %pow(2,32) это ограничение числа до 32 бит
	H[0]=(H[0]+A)%pow(2,32);
	H[1]=(H[1]+B)%pow(2,32);
	H[2]=(H[2]+C)%pow(2,32);
	H[3]=(H[3]+D)%pow(2,32);
	H[4]=(H[4]+E)%pow(2,32);
КонецПроцедуры

// Для ускорения вычисления хеша запишем все функции в одну строку
FUNCTION LR(A,S) RETURN INT(A/T1[32-S])+T1[S]*(A%T1[32-S]);ENDFUNCTION
FUNCTION F1(VAL A,VAL B,VAL C) R=0;FOR I=1 TO 32 DO M=T1[32-I];R=R+M*?((A>=M)<>((B>=M)AND((C>=M)<>(A>=M))),1,0);A=?(A<M,A,A-M);B=?(B<M,B,B-M);C=?(C<M,C,C-M);ENDDO;RETURN R;ENDFUNCTION
FUNCTION F2(VAL A,VAL B,VAL C) R=0;FOR I=1 TO 32 DO M=T1[32-I];R=R+M*?((A<M)=(B<M)=(C<M),0,1);A=?(A<M,A,A-M);B=?(B<M,B,B-M);C=?(C<M,C,C-M);ENDDO;RETURN R;ENDFUNCTION
FUNCTION F3(VAL A,VAL B,VAL C) R=0;FOR I=1 TO 32 DO M=T1[32-I];R=R+M*?(((A>=M)AND(B>=M))OR((C>=M)AND((A>=M)OR(B>=M))),1,0);A=?(A<M,A,A-M);B=?(B<M,B,B-M);C=?(C<M,C,C-M);ENDDO;RETURN R;ENDFUNCTION
FUNCTION W(VAL A,VAL B,VAL C, VAL D) R=0;FOR I=1 TO 32 DO M=T1[32-I];R=R+?(I=1,1,M*2)*?((A<M)=(B<M)=(C<M)=(D<M),0,1);A=?(A<M,A,A-M);B=?(B<M,B,B-M);C=?(C<M,C,C-M);D=?(D<M,D,D-M);ENDDO;RETURN R;ENDFUNCTION
FUNCTION SHA1_ROUND(W,H) FOR I=16 TO 79 DO W[I]=(W(W[I-3],W[I-8],W[I-14],W[I-16]));ENDDO;A=H[0];B=H[1];C=H[2];D=H[3];E=H[4];FOR I=0 TO 79 DO T=(LR(A,5)+?(I<20,F1(D,B,C),?(I>39 AND I<60,F3(B,C,D),F2(B,C,D)))+E+K[INT(I/20)]+W[I])%4294967296;E=D;D=C;C=LR(B,30);B=A;A=T;ENDDO;H[0]=(H[0]+A)%4294967296;H[1]=(H[1]+B)%4294967296;H[2]=(H[2]+C)%4294967296;H[3]=(H[3]+D)%4294967296;H[4]=(H[4]+E)%4294967296;ENDFUNCTION
FUNCTION SHA1_H(S) W=NEW ARRAY(80);L=0;R=0;H=NEW ARRAY(5);H[0]=1732584193;H[1]=4023233417;H[2]=2562383102;H[3]=271733878;H[4]=3285377520;FOR I=1 TO STRLEN(S)DO C=CHARCODE(S,I);IF C<128 THEN N=C;G=0;ELSE G=INT((LOG(C)/LOG(2)-6)/5)+1;D=128;FOR J=1 TO G DO D=D+T1[7-J];ENDDO;M=T6[G];N=INT(C/M)+D;C=C%M;ENDIF;FOR J=0 TO G DO R=R+T8[3-L%4]*N;L=L+1;IF L%4=0 THEN W[INT((L-1)%64/4)]=R;R=0;IF L%64=0 THEN SHA1_ROUND(W,H);ENDIF;ENDIF;IF J=G THEN BREAK;ENDIF;M=T6[G-J-1];N=INT(C/M)+128;C=C%M;ENDDO;ENDDO;R=R+T8[3-L%4]*128;W[INT(L%64/4)]=R;FOR I=INT(L%64/4)+1 TO 15 DO W[I]=0;ENDDO;IF L%64>55 THEN SHA1_ROUND(W,H);FOR I=0 TO 14 DO W[I]=0;ENDDO;ENDIF;W[14]=INT(L*8/4294967296);W[15]=L*8%4294967296;SHA1_ROUND(W,H);RETURN H;ENDFUNCTION
FUNCTION SHA1(S) EXPORT H=SHA1_H(S);R=NEW ARRAY(5);FOR I=0 TO 4 DO R[I]="";ENDDO;FOR I = 1 TO 8 DO FOR J = 0 TO 4 DO R[J]=MID(HEX,H[J]%16+1,1)+R[J];H[J]=INT(H[J]/16);ENDDO;ENDDO;RETURN R[0]+R[1]+R[2]+R[3]+R[4];ENDFUNCTION
FUNCTION SHA1_BASE64(S) EXPORT H=SHA1_H(S);A=0;B=0;R="";FOR EACH E IN H DO B=B+32;A=A*4294967296+E;WHILE B>=6 DO B=B-6;R=R+MID(ALF_BASE64,INT(A/T1[B])+1,1);A=A%T1[B];ENDDO;ENDDO;R=R+MID(ALF_BASE64,A*4+1,1)+"=";RETURN R;ENDFUNCTION

// Инициализация констант
ALF_BASE64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
HEX="0123456789ABCDEF";
K=Новый Массив(4);
K[0]=1518500249;
K[1]=1859775393;
K[2]=2400959708;
K[3]=3395469782;

// Для некоторого ускорения, наряду с функциями записанными в одну строку, используем кэширование часто используемых значений функции возведения в степень - pow
// Кэширование 2 в степени от 0 до 31
T1=Новый Массив(32);
Для I=0 По 31 Цикл 
	T1[I]=POW(2,I);
КонецЦикла;
// Кэширование 64 в степени от 0 до 5
T6=Новый Массив(6);
Для I=0 По 5 Цикл
	T6[I]=POW(64,I);
КонецЦикла;
// Кэширование 256 в степени от 0 до 3
T8=Новый Массив(4);
Для I=0 По 3 Цикл 
	T8[I]=POW(256,I);
КонецЦикла;
